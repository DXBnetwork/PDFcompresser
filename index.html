fix this:<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>PDF Splitter by Size</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 0 20px; }
    h1 { text-align: center; }
    input, button { display: block; width: 100%; margin: 10px 0; padding: 10px; font-size: 1rem; }
  </style>
</head>
<body>
  <h1>PDF Splitter by Size</h1>
  <input type="file" id="pdfFile" accept="application/pdf">
  <label for="maxSize">Max size (MB):</label>
  <input type="number" id="maxSize" value="10" min="1" step="1">
  <button id="splitBtn">Split & Download</button>

  <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
  document.getElementById('splitBtn').addEventListener('click', async () => {
    const fileInput = document.getElementById('pdfFile');
    if (!fileInput.files.length) { alert('Please select a PDF file.'); return; }
    const file = fileInput.files[0];
    const arrayBuffer = await file.arrayBuffer();
    const srcPdf = await PDFLib.PDFDocument.load(arrayBuffer);
    const totalPages = srcPdf.getPageCount();
    const maxBytes = parseInt(document.getElementById('maxSize').value) * 1024 * 1024;

    let pagesChunk = [];
    let chunkIndex = 1;
    const parts = [];

    for (let i = 0; i < totalPages; i++) {
      const testPages = pagesChunk.concat(i);
      const testDoc = await PDFLib.PDFDocument.create();
      const copied = await testDoc.copyPages(srcPdf, testPages);
      copied.forEach(p => testDoc.addPage(p));
      const bytes = await testDoc.save();

      if (bytes.byteLength <= maxBytes) {
        pagesChunk = testPages;
      } else {
        if (pagesChunk.length === 0) pagesChunk = testPages;
        // finalize this chunk
        const outDoc = await PDFLib.PDFDocument.create();
        const pagesToWrite = await outDoc.copyPages(srcPdf, pagesChunk);
        pagesToWrite.forEach(p => outDoc.addPage(p));
        const outBytes = await outDoc.save();
        parts.push({ name: `part_${chunkIndex}.pdf`, blob: new Blob([outBytes], { type: 'application/pdf' }) });
        chunkIndex++;
        pagesChunk = [i];
      }
    }

    // remaining pages
    if (pagesChunk.length) {
      const outDoc = await PDFLib.PDFDocument.create();
      const pagesToWrite = await outDoc.copyPages(srcPdf, pagesChunk);
      pagesToWrite.forEach(p => outDoc.addPage(p));
      const outBytes = await outDoc.save();
      parts.push({ name: `part_${chunkIndex}.pdf`, blob: new Blob([outBytes], { type: 'application/pdf' }) });
    }

    // package and download
    if (parts.length > 1) {
      const zip = new JSZip();
      parts.forEach(p => zip.file(p.name, p.blob));
      const zipBlob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(zipBlob);
      const link = document.createElement('a');
      link.href = url;
      link.download = 'pdf_parts.zip';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } else if (parts.length === 1) {
      const single = parts[0];
      const url = URL.createObjectURL(single.blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = single.name;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } else {
      alert('No PDF pages were processed.');
    }
  });
  </script>
</body>
</html>
